---
layout: single
title: Iniciando Laboratorio en Mobile Pentesting en Android
date: 2021-05-22
classes: wide
header:
  teaser: /assets/images/masthead.png
categories:
  - Mobile
  - Pentesting
  - Android
  - Burpsuite
tags:
  - H4ch1rou
  - 
  -
---


Preparando nuestro Laboratorio de Pentesting Mobile (Android)
---

El pentesting Mobile en la actualidad es un punto crucial a la hora de lanzar nuestras aplicaciones a produccion, en la actualidad la mayoria de empresas estan mudandose a la tecnología mobile, esto es por el incremento del uso del celular en la actualidad, las personas tecnicas y no tecnicas ya practicamente es un articulo impresendible en su dia dia, puedes olvidar tu mochila pero no tu celular, por lo tanto es un factor de riesgo importante tanto para los usuarios como para las organizaciones, cada dia se traspasan las operaciones que se realizaban en la traquilidad del hogar al celular. Por ejemplo, consultas de saldo, transacciones bancarias, reserva de horas medicas, compras online, despachos, etc. 
Esto genera que los ciberdelincuentes busquen vulnerabilidades que les permitan realizar algun tipo de fraude a traves de estas aplicaciones. 



Instalacion de maquina virtual
---

Primero que nada debemos tener un entorno donde podemos realizar nuestras pruebas, no siempre dispondremos de un dispositivo fisico para realizar estas pruebas por lo tanto deberemos recurrir a alguna maquina virtual para android. 


Puede ser
* Gennymotion  https://www.genymotion.com/ 
* Bluestack    https://www.bluestacks.com/es/index.html
* Nox Player   https://es.bignox.com/


Para este laboratorio usaremos gennymotion, este nos permite emular diversos sistemas operativos android ademas que las maquinas virtuales creadas ya vienen con los dipositivos con permisos de root (Rooteados), por lo tanto seran ideales para nuestras pruebas. 


Para instalar en entornos debian 

* Primero que nada tenemos que tener instalado virtual box 6.1  https://www.virtualbox.org/wiki/Linux_Downloads

ingresamos a la siguiente URL https://www.genymotion.com/download/ 
esto nos descargara el archivo genymotion-3.2.1-linux_x64.bin

ejecutamos y si todo sale bien podremos ejecutar gennymotion sin problemas 

![image-center](/assets/images/mobile/gennymotion-main.png){: .align-center }


Si le damos al simbolo [+] podremos descargar en instalar varias de las versiones de android que tiene disponible, para nuestro laboratorio usaremos la versión
"Samsung Galaxy S7 " con android 8.0 

![image-center](/assets/images/mobile/gennymotion-vmSGS7.png){: .align-center }

Configuracion 

System

* Android Version 8.0
* Processors 4
* Memory size 4096 (minimo 2GB recomendado 4GB)

Network Mode 
* NAT (Default)

** La primera vez que instales una version de android tardara un tiempo adicional ya que debe realizar la descarga de la vm

Luego de la instalacion ejecutamos la maquina y veremos lo siguiente 

![image-center](/assets/images/mobile/gennymotion-vmSGS7_run.png){: .align-center }


Android Device Bridge (ADB)
---

Android Debug Bridge (adb) es una herramienta de línea de comandos versátil que te permite comunicarte con un dispositivo. El comando adb permite realizar una variedad de acciones en el dispositivo, como instalar y depurar apps, y proporciona acceso a un shell de Unix que puedes usar para ejecutar distintos comandos en un dispositivo.

```bash
# Instalacion Linux
  sudo apt-get install adb

  Leyendo lista de paquetes... Hecho
Creando árbol de dependencias... Hecho
Leyendo la información de estado... Hecho
Se instalarán los siguientes paquetes NUEVOS:
  adb
0 actualizados, 1 nuevos se instalarán, 0 para eliminar y 11 no actualizados.
Se necesita descargar 0 B/104 kB de archivos.
Se utilizarán 267 kB de espacio de disco adicional después de esta operación.
Seleccionando el paquete adb previamente no seleccionado.
(Leyendo la base de datos ... 225998 ficheros o directorios instalados actualmente.)
Preparando para desempaquetar .../adb_1%3a10.0.0+r36-7_amd64.deb ...
Desempaquetando adb (1:10.0.0+r36-7) ...
Configurando adb (1:10.0.0+r36-7) ...
Procesando disparadores para man-db (2.9.4-2) ...
```

```bash 
# alternativa 
sudo apt-get install android-tools-adb
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias... Hecho
Leyendo la información de estado... Hecho
Nota, seleccionando «adb» en lugar de «android-tools-adb»
Se instalarán los siguientes paquetes NUEVOS:
  adb
0 actualizados, 1 nuevos se instalarán, 0 para eliminar y 11 no actualizados.
Se necesita descargar 0 B/104 kB de archivos.
Se utilizarán 267 kB de espacio de disco adicional después de esta operación.
Seleccionando el paquete adb previamente no seleccionado.
(Leyendo la base de datos ... 225998 ficheros o directorios instalados actualmente.)
Preparando para desempaquetar .../adb_1%3a10.0.0+r36-7_amd64.deb ...
Desempaquetando adb (1:10.0.0+r36-7) ...
Configurando adb (1:10.0.0+r36-7) ...
Procesando disparadores para man-db (2.9.4-2) ... 
```

Lo primero que podemos hacer con ADB es identificar los dispotivos android que tenemos disponibles, para eso ejecutamos:

```bash
 adb devices

# nos entregara algo parecido a esto
List of devices attached
192.168.56.101:5555	device


## para ingresar a una consola podemos usar
adb shell 

vbox86p:/ # whoami
root
vbox86p:/ # 
# con esto ya podremos ingresar a la consola de android para ejecutar ciertos comandos
```

Instalacion de Frida 
---
Frida es un conjunto de herramienta de instrumentacion de codigo dinamico. Permite inuectar codigo JavaScript o sus propias bibliotecas en aplicaciones nativas en windows, MacOS, Linux, IOS, Android y QNX.


* python -m pip install Frida
* python -m pip install objection
* python -m pip install frida-tools


Una ves instalado todo eso, debemos descargar frida-server, para eso debemos primero identificar la arquitectura de nuestro dispositivo

```bash
adb shell getprop ro.product.cpu.abi
x86
```

Ingresamos al siguiente link 
https://github.com/frida/frida/releases/

y buscamos la version correspondiente al frida-server que necesitamos frida-server-xx.xx.x-android-x86 o  frida-server-xx.xx.x-android-x86_64

![image-center](/assets/images/mobile/gennymotion-vmSGS7_frida_1.png){: .align-center }

Descomprimimos la version de frida que vamos a utilizar y la cargamos en nuestro dispositivo 
}

```bash
#cargamos frida en nuestro dispositivo 
adb push frida-server /data/local/tmp/frida-server 
frida-server-xx.x.x-android-x86: 1 file pushed. 84.3 MB/s (30439672 bytes in 0.344s)

#le damos permisos full al server
adb shell chmod 777 /data/local/tmp/frida-server

```

Un script Clasico para saltar el control de SSL pinning es el siguiente

Tenemos 2 formas de ejecucion 

```bash
# de esta forma lo usaremos sin necesidad de descargar el archivo js que vamos a inyectar
frida --codeshare pcipolloni/universal-android-ssl-pinning-bypass-with-frida -f YOUR_BINARY 
```

```java
/* 
   Android SSL Re-pinning frida script v0.2 030417-pier 

   $ adb push burpca-cert-der.crt /data/local/tmp/cert-der.crt
   $ frida -U -f it.app.mobile -l frida-android-repinning.js --no-pause

   https://techblog.mediaservice.net/2017/07/universal-android-ssl-pinning-bypass-with-frida/
   
   UPDATE 20191605: Fixed undeclared var. Thanks to @oleavr and @ehsanpc9999 !
*/

setTimeout(function(){
    Java.perform(function (){
    	console.log("");
	    console.log("[.] Cert Pinning Bypass/Re-Pinning");

	    var CertificateFactory = Java.use("java.security.cert.CertificateFactory");
	    var FileInputStream = Java.use("java.io.FileInputStream");
	    var BufferedInputStream = Java.use("java.io.BufferedInputStream");
	    var X509Certificate = Java.use("java.security.cert.X509Certificate");
	    var KeyStore = Java.use("java.security.KeyStore");
	    var TrustManagerFactory = Java.use("javax.net.ssl.TrustManagerFactory");
	    var SSLContext = Java.use("javax.net.ssl.SSLContext");

	    // Load CAs from an InputStream
	    console.log("[+] Loading our CA...")
	    var cf = CertificateFactory.getInstance("X.509");
	    
	    try {
	    	var fileInputStream = FileInputStream.$new("/data/local/tmp/cert-der.crt");
	    }
	    catch(err) {
	    	console.log("[o] " + err);
	    }
	    
	    var bufferedInputStream = BufferedInputStream.$new(fileInputStream);
	  	var ca = cf.generateCertificate(bufferedInputStream);
	    bufferedInputStream.close();

		var certInfo = Java.cast(ca, X509Certificate);
	    console.log("[o] Our CA Info: " + certInfo.getSubjectDN());

	    // Create a KeyStore containing our trusted CAs
	    console.log("[+] Creating a KeyStore for our CA...");
	    var keyStoreType = KeyStore.getDefaultType();
	    var keyStore = KeyStore.getInstance(keyStoreType);
	    keyStore.load(null, null);
	    keyStore.setCertificateEntry("ca", ca);
	    
	    // Create a TrustManager that trusts the CAs in our KeyStore
	    console.log("[+] Creating a TrustManager that trusts the CA in our KeyStore...");
	    var tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
	    var tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
	    tmf.init(keyStore);
	    console.log("[+] Our TrustManager is ready...");

	    console.log("[+] Hijacking SSLContext methods now...")
	    console.log("[-] Waiting for the app to invoke SSLContext.init()...")

	   	SSLContext.init.overload("[Ljavax.net.ssl.KeyManager;", "[Ljavax.net.ssl.TrustManager;", "java.security.SecureRandom").implementation = function(a,b,c) {
	   		console.log("[o] App invoked javax.net.ssl.SSLContext.init...");
	   		SSLContext.init.overload("[Ljavax.net.ssl.KeyManager;", "[Ljavax.net.ssl.TrustManager;", "java.security.SecureRandom").call(this, a, tmf.getTrustManagers(), c);
	   		console.log("[+] SSLContext initialized with our custom TrustManager!");
	   	}
    });
},0);
```